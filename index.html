<!DOCTYPE html>
<html lang="zh">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <title>幼儿形状认知游戏 - 纯净版</title>
    <style>
        :root {
            --bg-color: #eef2ff;
            --target-shadow: #cbd5e1;
        }
        body { 
            margin: 0; padding: 0; background: var(--bg-color); 
            font-family: sans-serif; display: flex; flex-direction: column; 
            align-items: center; height: 100vh; overflow: hidden; touch-action: none;
        }

        /* 顶部导航按钮 - 增大点击区域 */
        .controls { 
            height: 15vh; display: flex; align-items: center; gap: 20px; z-index: 10;
        }
        button { 
            padding: 12px 24px; border: none; border-radius: 50px; background: white; 
            box-shadow: 0 4px 6px rgba(0,0,0,0.1); font-size: 18px; font-weight: bold; color: #475569;
        }
        button.active { background: #6366f1; color: white; }

        /* 游戏主区域 */
        .game-container {
            width: 95vw; height: 80vh; max-width: 900px;
            background: rgba(255, 255, 255, 0.7); border-radius: 30px;
            display: flex; flex-direction: column; padding: 20px; box-sizing: border-box;
        }

        .zone {
            flex: 1; display: flex; flex-wrap: wrap; justify-content: center;
            align-content: center; gap: 30px;
        }

        /* 形状基础定义 */
        .shape-common { width: 80px; height: 80px; position: relative; }
        
        /* 几何图形绘制 */
        .circle { border-radius: 50%; }
        .square { border-radius: 8px; }
        .triangle { 
            width: 0; height: 0; background: transparent !important;
            border-left: 40px solid transparent; border-right: 40px solid transparent; 
            border-bottom: 80px solid; 
        }
        .star { 
            clip-path: polygon(50% 0%, 61% 35%, 98% 35%, 68% 57%, 79% 91%, 50% 70%, 21% 91%, 32% 57%, 2% 35%, 39% 35%);
        }

        /* 目标框样式：通过透明度形成“影子”效果 */
        .target {
            width: 90px; height: 90px; border: 4px dashed var(--target-shadow);
            border-radius: 15px; display: flex; align-items: center; justify-content: center;
            background: rgba(255,255,255,0.5);
        }
        .target .shape-common { opacity: 0.2; filter: grayscale(1); transform: scale(0.9); }
        .target.matched { border: 4px solid #10b981; background: #f0fdf4; border-style: solid; }
        .target.matched .shape-common { opacity: 1; filter: none; transform: scale(1); transition: all 0.3s; }

        /* 拖拽中的形状 */
        .drag-item { cursor: pointer; z-index: 100; }
        .dragging { transform: scale(1.3); opacity: 0.9; position: fixed !important; pointer-events: none; }
    </style>
</head>
<body>

    <div class="controls">
        <button onclick="initGame(3)" id="btn-3" class="active">3</button>
        <button onclick="initGame(5)" id="btn-5">5</button>
        <button onclick="initGame(8)" id="btn-8">8</button>
    </div>

    <div class="game-container">
        <div class="zone" id="targetZone"></div>
        <hr style="width: 100%; border: 1px dashed #cbd5e1; margin: 0;">
        <div class="zone" id="sourceZone"></div>
    </div>

    <script>
        const shapeTypes = ['circle', 'square', 'triangle', 'star'];
        const colors = ['#ef4444', '#3b82f6', '#22c55e', '#f59e0b', '#8b5cf6', '#ec4899', '#06b6d4', '#f97316'];

        let activeEl = null;
        let startOffset = { x: 0, y: 0 };

        function initGame(count) {
            // 更新按钮
            document.querySelectorAll('button').forEach(b => b.classList.remove('active'));
            document.getElementById(`btn-${count}`).classList.add('active');

            const targetZone = document.getElementById('targetZone');
            const sourceZone = document.getElementById('sourceZone');
            targetZone.innerHTML = '';
            sourceZone.innerHTML = '';

            // 生成不重复的形状+颜色组合
            let combinations = [];
            let tempTypes = [...shapeTypes];
            let tempColors = [...colors];
            
            // 洗牌算法保证随机
            tempColors.sort(() => Math.random() - 0.5);

            for(let i=0; i<count; i++) {
                // 如果形状用完了，重新洗牌形状池，但颜色保持唯一
                if(tempTypes.length === 0) tempTypes = [...shapeTypes];
                const typeIndex = Math.floor(Math.random() * tempTypes.length);
                
                combinations.push({
                    type: tempTypes.splice(typeIndex, 1)[0],
                    color: tempColors[i],
                    id: `item-${i}`
                });
            }

            // 渲染目标影子 (打乱顺序)
            [...combinations].sort(() => Math.random() - 0.5).forEach(conf => {
                const slot = document.createElement('div');
                slot.className = 'target';
                slot.dataset.matchId = conf.id;
                
                const shadow = document.createElement('div');
                shadow.className = `shape-common ${conf.type}`;
                if(conf.type === 'triangle') shadow.style.borderBottomColor = '#000';
                else shadow.style.backgroundColor = '#000';
                
                slot.appendChild(shadow);
                targetZone.appendChild(slot);
            });

            // 渲染彩色形状
            combinations.forEach(conf => {
                const el = document.createElement('div');
                el.className = `shape-common ${conf.type} drag-item`;
                el.dataset.id = conf.id;
                
                if(conf.type === 'triangle') el.style.borderBottomColor = conf.color;
                else el.style.backgroundColor = conf.color;

                el.ontouchstart = handleTouchStart;
                sourceZone.appendChild(el);
            });
        }

        function handleTouchStart(e) {
            e.preventDefault();
            activeEl = e.currentTarget;
            const touch = e.touches[0];
            const rect = activeEl.getBoundingClientRect();
            
            startOffset = {
                x: touch.clientX - rect.left,
                y: touch.clientY - rect.top
            };

            activeEl.classList.add('dragging');
            updatePosition(touch.clientX, touch.clientY);

            document.ontouchmove = (ev) => updatePosition(ev.touches[0].clientX, ev.touches[0].clientY);
            document.ontouchend = handleTouchEnd;
        }

        function updatePosition(x, y) {
            if(!activeEl) return;
            activeEl.style.left = (x - startOffset.x) + 'px';
            activeEl.style.top = (y - startOffset.y) + 'px';
        }

        function handleTouchEnd(e) {
            if(!activeEl) return;
            const touch = e.changedTouches[0];
            const targets = document.querySelectorAll('.target');
            let success = false;

            targets.forEach(target => {
                if(target.classList.contains('matched')) return;
                
                const rect = target.getBoundingClientRect();
                if(touch.clientX > rect.left && touch.clientX < rect.right &&
                   touch.clientY > rect.top && touch.clientY < rect.bottom) {
                    
                    if(target.dataset.matchId === activeEl.dataset.id) {
                        target.classList.add('matched');
                        activeEl.remove(); // 移除拖拽元素，目标框内的影子变色
                        success = true;
                    }
                }
            });

            if(!success) {
                activeEl.classList.remove('dragging');
                activeEl.style.position = 'static';
            }
            
            activeEl = null;
            document.ontouchmove = null;
            checkWin();
        }

        function checkWin() {
            const matched = document.querySelectorAll('.target.matched').length;
            const total = document.querySelectorAll('.target').length;
            if(matched === total) {
                setTimeout(() => {
                    // 简单的视觉反馈
                    document.body.style.backgroundColor = '#dcfce7';
                    setTimeout(() => {
                        document.body.style.backgroundColor = '#eef2ff';
                        initGame(total);
                    }, 1000);
                }, 500);
            }
        }

        initGame(3);
    </script>
</body>
</html>
